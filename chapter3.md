# 第3章 程序的机器级表示

## 3.1 历史观点

- 一个处理器支持的指令和指令的字节级编码称为它的指令集体系结构（ISA）
  - 处理器有很多，各自有不同的ISA
  - ISA为编译器编写和处理器设计之间提供了抽象层？？？
    - 编译器编写只需要知道允许哪些指令，以及它们如何编码
    - 处理器设计者要造出这些指令的处理器

###

## 3.2 程序编码

- gcc命令的编译选项-Og
- 源代码到可执行代码的流程
  - 预处理
  - 编译
  - 汇编
  - 链接

### 3.2.1 机器级代码

- 在机器级编程当中重要的两种抽象
  - 由指令集架构（ISA）来定义机器级程序的格式和行为
    - 大多数ISA把程序的行为描述成看起来是按顺序执行
    - 但是处理器经常并发执行许多指令
    - 保证实际的并发执行和ISA的顺序执行，效果完全一致
  - 物理地址和虚拟地址
- 机器代码对程序员可见的处理器状态（对比C）
  - 程序计数器（"PC"，在x86-64中用%rip表示），给出将要执行的下一条指令在内存中的地址
  - 整数寄存器文件，包含16个命名的位置，分别存储64位，可以存地址或整数数据
  - 条件码寄存器，保存最近执行的算术或逻辑指令的状态信息，通常用于实现if和while语句
  - 向量寄存器，可以存放一个或多个整数或浮点数值
- 程序内存
  - 程序内存的组成
    - 程序的可执行机器代码
    - 操作系统需要的一些信息
    - 运行时栈
    - 用户分配的内存块（堆）
  - 程序内存用虚拟地址寻址

### 3.2.2 代码示例

###

### 3.2.3 关于格式的注解

###

## 3.3 数据格式

- 图3-1

## 3.4 访问信息

- 一个x86-64的CPU包含一组16个64位的通用目的寄存器

  - 图3-2

  - 可以通过字节级操作访问一个寄存器的低字节
    - 生成1字节或2字节的指令会保持剩下的字节不变
    - 生成4字节的指令会把高位4个字节置为0
  - 一些特殊用法的寄存器
    - 栈指针%rsp
      - 指明运行时栈的结束位置
      - 有些程序会明确读写这个寄存器
    - 更多惯例见描述过程的实现（尤其3.7）

### 3.4.1 操作数提示符

- 大多数指令有一个或多个操作数，指示出执行一个操作中要用到的源数据值，和放置结果的目的位置
  - 操作数格式见图3-3
  - 源数据值的类型
    - 以常数形式给出
    - 从寄存器或内存中独处
  - 结果可以存放在寄存器或内存中
  - 操作数的类型
    - 立即数，表示常数值（这个操作数本身就是要的数据）
    - 寄存器
      - r<sub>a</sub>表示这个寄存器本身
      - R[r<sub>a</sub>]表示这个寄存器存的值
    - 内存引用
      - M<sub>b</sub>[Addr]表示对存储在内存中的，从地址Addr开始的b个字节值的引用
      - 可以省去下标b
  - 例子见练习题3.1（和图3-3对照）

### 3.4.2 数据传送指令

- MOV指令
  - 把数据从源位置复制到目的位置，其余不作任何变化
  - 源操作数是一个立即数（好像也可以是寄存器？？？），存储在寄存器或者内存中
  - 目的操作数是一个位置，可能是一个寄存器或一个内存地址
  - x86-64的限制，两个操作数不能都指向内存位置
  - MOV指令见图3-4
- MOVZ指令
  - 源值较小，目的较大，把目的中的剩余字节填充为0
  - 见图3-5，最后两个字符是大小提示符
    - 第一个字符指定源的大小
    - 第二个字符指定目的的大小
- MOVS指令
  - 和MOVZ类似，不过填充是通过符号扩展来填充

### 3.4.3 数据传送示例

- 代码见图3-7

- 局部变量通常放在寄存器（访问速度快）
- ###

### 3.4.4 压入和弹出栈数据

- 在x86-64中，程序站放在内存中的某个（连续）区域

- 栈指针%rsp保存着栈顶元素的地址

- pushq和popq指令

  - 只有一个操作数，如

    ```x86asm
    puhq %rbp // 把寄存器rbp存的值压入栈
    ```

    等价于

    ```x86asm
    subq $8, %rsp // 寄存器rsp存的值-8（栈指针移动）
    movq %rbp, (%rsp) // 把寄存器rbp存的值压入栈
    ```

## 3.5 算术和逻辑操作

- x86-64的一些整数和逻辑操作见图3-10

### 3.5.1 加载有效地址

- 加载有效地址指令leaq

  - 形式和movq类似，但第一个操作数不是从指定的位置读入数据

  - 回忆movq

    ```x86asm
    movq %rdx, %rax
    ```

  - leaq

    ```x86asm
    leaq (%rdi, %rsi, 4), %rax
    ```

### 3.5.2 一元和二元操作

- 一元操作

  - 只有一个操作数，既是源又是目的
  - 操作数可以使寄存器或一个内存位置
  - 自增自减

- 二元操作

  - 第二个操作数既是源又是目的

  - 例如

    ```x86asm
    subq %rax, %rdx // 使寄存器%rdx中的值减去rax中的值
    ```

### 3.5.3 移位操作

- 第一个操作数是移位量，第二个操作数是要移位的数
- 可以是算术或逻辑右移
- 移位量是立即数或者放在单字节寄存器%cl中（移位指令只能把这个寄存器作为操作数）

### 3.5.4 讨论

##

### 3.5.5 特殊的算术操作

###

## 3.6 控制

- 之前都是直线代码的行为，而C语言有些结构（条件语句、循环语句、分支语句等等），要求有条件地执行
- jump指令可以改变一组机器代码指令的执行顺序
- 本节会涉及实现条件操作的两种方式，然后描述表达循环和switch语句的方法

### 3.6.1 条件码

- 除了整数寄存器，CPU还维护者一组单个位的条件码寄存器
- 最常用的条件码有
  - CF
  - ZF
  - SF
  - OF
- 一些会改变条件码的指令
  - ADD指令
  - leaq不改变任何条件码
  - CMP和SUB指令类似，但是只改变条件码
  - TEST和AND指令类似，但是只改变条件码

### 3.6.2 访问条件码

- 条件码通常不会直接读取，用到条件码的有以下几种场景

  - 根据条件码的某种组合，将一个字节设为0或1
    - 图3-14，注意“效果”一列即可

  - 可以条件跳转到程序的某个其他部分（3.6.3）
  - 可以有条件地传送数据（见后面）

### 3.6.3 跳转指令

- 图3-15列出了一些跳转指令

  - 无条件跳转和条件跳转

    - jmp指令是无条件跳转

    - 其它跳转指令都是条件跳转，是否跳转根据条件码决定

  - 直接跳转和间接跳转

    - 直接跳转

      ```x86asm
          movq $0,%rax
          jmp .L1
          movq (%rax),%rdx
      .L1:
      	popq %rdx
      ```

    - 间接跳转

      ```x86asm
      jmp *%rax // 用寄存器%rax中的值作为跳转目标
      jmp *%rax // 用寄存器%rax中的值作为读地址，从内存中读出跳转目标
      ```

### 3.6.4 跳转指令的编码

###

### 3.6.5 用条件控制来实现条件分支

- 图3-16，汇编代码第8行
- 实现起来类似于goto

###  3.6.6 用条件传送来实现条件分支

- 3.6.5的方法简单易懂，但是在现代处理器上比较低效
- 图3-17
- 为什么条件传送比条件控制要快，涉及到流水线（第4，5章）

### 3.6.7 循环

###

### 3.6.8 switch语句

###

## 3.7 过程

