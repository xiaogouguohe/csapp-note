# 第3章 程序的机器级表示

## 3.1 历史观点

###

## 3.2 程序编码

- gcc命令的编译选项-Og
- 源代码到可执行代码的流程
  - 预处理
  - 编译
  - 汇编
  - 链接

### 3.2.1 机器级代码

- 在机器级编程当中重要的两种抽象
  - 由指令集架构（ISA）来定义机器级程序的格式和行为
    - 大多数ISA把程序的行为描述成看起来是按顺序执行
    - 但是处理器经常并发执行许多指令
    - 保证实际的并发执行和ISA的顺序执行，效果完全一致
  - 物理地址和虚拟地址
- 机器代码对程序员可见的处理器状态（对比C）
  - 程序计数器（"PC"，在x86-64中用%rip表示），给出将要执行的下一条指令在内存中的地址
  - 整数寄存器文件，包含16个命名的位置，分别存储64位，可以存地址或整数数据
  - 条件码寄存器，保存最近执行的算术或逻辑指令的状态信息，通常用于实现if和while语句
  - 向量寄存器，可以存放一个或多个整数或浮点数值
- 程序内存
  - 程序内存的组成
    - 程序的可执行机器代码
    - 操作系统需要的一些信息
    - 运行时栈
    - 用户分配的内存块（堆）
  - 程序内存用虚拟地址寻址

### 3.2.2 代码示例

###

### 3.2.3 关于格式的注解

###

## 3.3 数据格式

- 图3-1

## 3.4 访问信息

- 一个x86-64的CPU包含一组16个64位的通用目的寄存器

  - 图3-2

  - 可以通过字节级操作访问一个寄存器的低字节
    - 生成1字节或2字节的指令会保持剩下的字节不变
    - 生成4字节的指令会把高位4个字节置为0
  - 一些特殊用法的寄存器
    - 栈指针%rsp
      - 指明运行时栈的结束位置
      - 有些程序会明确读写这个寄存器
    - 更多惯例见描述过程的实现（尤其3.7）

### 3.4.1 操作数提示符

- 大多数指令有一个或多个操作数，指示出执行一个操作中要用到的源数据值，和放置结果的目的位置
  - 操作数格式见图3-3
  - 源数据值的类型
    - 以常数形式给出
    - 从寄存器或内存中独处
  - 结果可以存放在寄存器或内存中
  - 操作数的类型
    - 立即数，表示常数值（这个操作数本身就是要的数据）
    - 寄存器
      - r<sub>a</sub>表示这个寄存器本身
      - R[r<sub>a</sub>]表示这个寄存器存的值
    - 内存引用
      - M<sub>b</sub>[Addr]表示对存储在内存中的，从地址Addr开始的b个字节值的引用
      - 可以省去下标b
  - 例子见练习题3.1（和图3-3对照）

### 3.4.2 数据传送指令

- MOV指令
  - 把数据从源位置复制到目的位置，其余不作任何变化
  - 源操作数是一个立即数（好像也可以是寄存器？？？），存储在寄存器或者内存中
  - 目的操作数是一个位置，可能是一个寄存器或一个内存地址
  - x86-64的限制，两个操作数不能都指向内存位置
  - MOV指令见图3-4
- MOVZ指令
  - 源值较小，目的较大，把目的中的剩余字节填充为0
  - 见图3-5，最后两个字符是大小提示符
    - 第一个字符指定源的大小
    - 第二个字符指定目的的大小
- MOVS指令
  - 和MOVZ类似，不过填充是通过符号扩展来填充

### 3.4.3 数据传送示例

- 代码见图3-7

- 局部变量通常放在寄存器（访问速度快）
- ###

### 3.4.4 压入和弹出栈数据

- 在x86-64中，程序站放在内存中的某个（连续）区域

- 栈指针%rsp保存着栈顶元素的地址

- pushq和popq指令

  - 只有一个操作数，如

    ```x86asm
    puhq %rbp // 把寄存器rbp存的值压入栈
    ```

    等价于

    ```x86asm
    subq $8, %rsp // 寄存器rsp存的值-8（栈指针移动）
    movq %rbp, (%rsp) // 把寄存器rbp存的值压入栈
    ```

## 3.5 算术和逻辑操作

- x86-64的一些整数和逻辑操作见图3-10

### 3.5.1 加载有效地址

- 加载有效地址指令leaq

  - 形式和movq类似，但第一个操作数不是从指定的位置读入数据

  - 回忆movq

    ```x86asm
    movq %rdx, %rax
    ```

  - leaq

    ```x86asm
    leaq (%rdi, %rsi, 4), %rax
    ```

### 3.5.2 一元和二元操作

- 一元操作

  - 只有一个操作数，既是源又是目的
  - 操作数可以使寄存器或一个内存位置
  - 自增自减

- 二元操作

  - 第二个操作数既是源又是目的

  - 例如

    ```x86asm
    subq %rax, %rdx // 使寄存器%rdx中的值减去rax中的值
    ```

### 3.5.3 移位操作

- 第一个操作数是移位量，第二个操作数是要移位的数
- 可以是算术或逻辑右移
- 移位量是立即数或者放在单字节寄存器%cl中（移位指令只能把这个寄存器作为操作数）

### 3.5.4 讨论

##

### 3.5.5 特殊的算术操作

###

## 3.6 控制

- 之前都是直线代码的行为，而C语言有些结构（条件语句、循环语句、分支语句等等），要求有条件地执行
- jump指令可以改变一组机器代码指令的执行顺序
- 本节会涉及实现条件操作的两种方式，然后描述表达循环和switch语句的方法

### 3.6.1 条件码

- 除了整数寄存器，CPU还维护者一组单个位的条件码寄存器
- 最常用的条件码有
  - CF
  - ZF
  - SF
  - OF
- 一些会改变条件码的指令
  - ADD指令
  - leaq不改变任何条件码
  - CMP和SUB指令类似，但是只改变条件码
  - TEST和AND指令类似，但是只改变条件码

### 3.6.2 访问条件码

- 条件码通常不会直接读取，用到条件码的有以下几种场景

  - 根据条件码的某种组合，将一个字节设为0或1
    - 图3-14，注意“效果”一列即可

  - 可以条件跳转到程序的某个其他部分（3.6.3）
  - 可以有条件地传送数据（见后面）

### 3.6.3 跳转指令

- 图3-15列出了一些跳转指令

  - 无条件跳转和条件跳转

    - jmp指令是无条件跳转

    - 其它跳转指令都是条件跳转，是否跳转根据条件码决定

  - 直接跳转和间接跳转

    - 直接跳转

      ```x86asm
          movq $0,%rax
          jmp .L1
          movq (%rax),%rdx
      .L1:
      	popq %rdx
      ```

    - 间接跳转

      ```x86asm
      jmp *%rax // 用寄存器%rax中的值作为跳转目标
      jmp *%rax // 用寄存器%rax中的值作为读地址，从内存中读出跳转目标
      ```

### 3.6.4 跳转指令的编码

###

### 3.6.5 用条件控制来实现条件分支

- 图3-16，汇编代码第8行
- 实现起来类似于goto

###  3.6.6 用条件传送来实现条件分支

- 3.6.5的方法简单易懂，但是在现代处理器上比较低效
- 图3-17
- 为什么条件传送比条件控制要快，涉及到流水线（第4，5章）

### 3.6.7 循环

###

### 3.6.8 switch语句

###

## 3.7 过程

- 什么是过程
  - 一种抽象，比如函数、方法等（不用关心具体实现，只需要知道实现了什么）
- 现假设过程P调用过程Q，Q执行后返回到P，这些动作会包括下面的机制
  - 传递控制（3.7.2）
    - 进入过程Q的时候，程序计数器（PC）设置为Q的代码的起始地址
    - 返回是，要把程序计数器设置为P中调用Q的后面第一条指令的地址
  - 传递数据（3.7.3）
    - P要能为Q传递参数
    - Q要能够向P返回一个值
  - 分配和释放内存
    - 开始前Q可能申请空间
    - 返回前Q要释放空间

- x86-64如何实现过程
  - 一组特殊的指令和一些对机器资源（例如寄存器和程序内存）使用的约定规则
  - 这组规则尽可能地满足了“最低开销”

### 3.7.1 运行时栈

- 为什么用栈来管理过程调用
  - P调用Q时，P以及更上游都是被挂起的
  - ...
- 栈向低地址方向增长（也就是说栈顶是低地址）
- 过程的栈帧
  - 栈帧结构见图3-25
  - 当某个过程需要的存储空间超过寄存器能存放的大小时，就会在栈上分配空间，这个部分就是过程的栈帧
  - 大多数过程的栈帧都是定长的，但是有些过程需要变长的帧（3.10.5）
  - 通过寄存器，过程P可以传递6个整数值，更多的参数需要栈帧
  - 事实上大多数函数都没用到栈帧（寄存器够用）

### 3.7.2 转移控制

- 转移控制需要记录什么状态
  - 将控制从P到Q，只需要把PC设置为Q的代码的起始位置
  - 从Q返回时，处理器要记录它继续P的执行代码的位置

- 如何记录P的继续执行的位置

  - 通过call Q调用过程Q来记录
    - 该指令把地址A（返回地址）压入栈中，并且将PC设置为Q的起始地址
    - call指令的目标是，被调用过程起始的指令地址
    - 和跳转一样，调用可以是直接的，也可以是间接的
  - 指令ret从栈中弹出A，并把PC设置为A

- 一个过程调用的汇编代码例子

  ```c
  void mulstore(long x, long y, long *dest);
  
  int main() {
      long d;
      multstore(2, 3, &d);
      return 0;
  }
  
  void multstore2(long x, long y, long *dest) {
      // ...
  }
  ```

  汇编部分见书上

  - 在main函数中，执行到地址为0x400563的call指令（执行call指令之前），调用multstore，此时的状态见图3-26a
    - %rip是程序计数器，此时存的是当前这条指令（call指令）的地址
    - %rsp是栈顶指针，此时栈顶地址为0x7fffffffe840
  - 执行call之后，见图3-26b
    - 把返回地址（call的下一条指令地址）0x400568压入栈，因此%rsp值要减8（一个字节）
    - callq 400540，也就是说multstore的起始地址为0x400540，因此要跳到地址0x400540执行指令，所以把%rip值改为0x400540
  - 继续顺序执行，直到执行完ret
    - 把返回地址弹出栈，因此%rsp值加8
    - 把弹出的返回地址0x400568写入寄存器%rip

- 另一个例子
  
  - ###

### 3.7.3 数据传送

- 需要进行数据传送的场景
  - 过程调用把数据作为参数传递
  - 过程返回可能有返回值
- x86-64中，大部分过程间的数据传送是通过寄存器实现的
  - 通过寄存器传递参数，用到的寄存器见图3-28
  - 返回值一般在寄存器%rax中
- 大于6个整型参数，超过6个的部分要通过栈来传递
  - 参数7位于栈顶
  - 所有数据大小和8的倍数对齐
- 一个例子
  - ###

### 3.7.4 栈上的局部存储

- 有些时候，局部数据必须放在内存中，比如以下情况

  - 寄存器不足够存放所有本地数据
  - 对一个局部变量使用地址运算符'&'，因此必须为这个变量产生一个地址，才能进行取址运算
  - 某些局部变量是数组或结构体，因此必须能够通过数组或结构体引用被访问到（3.8和3.9）

- 一个例子，图3-31

  ```c
  long swap_add(long *xp, long *yp) {
      // ...
      return x + y;
  }
  
  long caller(){
      long arg1 = 534;
      long arg2 = 1057;
      long sum = swap_add(&arg1, &arg2);
      // ...
      return 0;
  }
  ```

  ```x86asm
  caller:
  	subq    $16, %rsp // 栈指针减16，也就是在栈上分配16字节（栈帧）
  	movq  $534, (%rsp) // 把两个地址存放到栈帧中
  	movq  $1057, 8(%rsp)
  	leaq     8(%rsp), %rsi // 这两个地址用做参数，因此要放到寄存器
  	movq  %rsp, %rdi
  	call      swap_add // 调用swap_add（call见3.7.2）
  	movq  (%rsp), rdx // 两个局部变量弹出栈帧
  	subq   8(%rsp), rdx
  	ret // ret见3.7.2
  ```
  - 对局部变量arg1、arg2进行了取址运算，因此要为这两个局部变量分配内存，不能只存在寄存器中，否则取址运算无法进行

- 另一个例子，图3-32

  - 汇编代码的2~15行都是为调用proc做准备
    - 第2行，为栈帧分配空间
    - 第3~6行，为局部变量建立栈帧
    - 第7~8行，为第8个参数（&x4）建立栈帧
      - 不能两个操作数都是内存（3.4.2），也就是说必须先存到寄存器，再建立栈帧（存到内存）
    - 第9行，为第7个参数（x4）建立栈帧
    - 第10~15行，把前面6个参数存到寄存器
  - 栈帧结构见图3-33

### 3.7.5 寄存器中的局部存储空间

- 寄存器是唯一被所有过程共享的资源，所以要确保P调用Q时，Q不会覆盖P稍后会使用的寄存器值
- x86-64的寄存器使用惯例
  - 被调用者保存寄存器
    - 当P调用Q时，Q必须保证这些寄存器的值在Q被调用时和返回P时是一样的
      - 可能是根本不去改变这些寄存器的值
      - 也可能是把原始的值压入栈中，再改变寄存器的值，然后在返回前从栈中弹出旧值，改回寄存器的值
        - 压入寄存器的值在栈帧中属于“保存的寄存器”这一部分（见图3-25）
    - 寄存器%rbx、%rbp和%r12~%r15被划分为被调用者保存寄存器
  - 调用者保存寄存器
    - 除了栈指针%rsp和被调用者保存寄存器，其它寄存器都被分类为调用者保存寄存器
      - 任何函数都可以修改它们
- 一个例子，图3-34
  - 调用Q时，需要保存什么
    - Q(y)要保存x
    - Q(x)要保存u
  - 第2~3行，用%rbp和%rbx来保存x和u

### 3.7.6 递归过程

- 和调用其他函数没有本质区别

## 3.8 数组分配和访问

### 3.8.1 基本原则

- 假设E是一个int型数组，现在想计算E[i]，E的地址放在寄存器%rdx中，i放在寄存器%rcx中，指令

  ```x86arm
  movl (%rdx, %rcx, 4), %eax
  ```

  会执行地址计算xE + 4i，读到这个内存位置的值，并把结果放到寄存器%eax中

### 3.8.2 指针运算

- 假设E是一个int型数组，起始地址和索引i分别放在寄存器%rdx和%rcx中，和E有关的一些表达式见书上表

### 3.8.3 嵌套的数组

###

### 3.8.4 定长数组

- 一个编译器优化的例子，图3-37
  - 为什么这样是一种优化？？？

### 3.8.5 变长数组

###

## 3.9 异质的数据结构

- 为了将不同类型的对象组合到一起来创建数据类型，C语言提供了两种方法
  - 结构，struct
  - 联合，union

### 3.9.1 结构

###

### 3.9.2 联合

- 联合和结构的差别
  
- 用不同的字段引用相同的内存块
  
- 联合比结构的优势，一个例子

  - 假设现在有一个二叉树，内部节点有指向两个孩子节点的指针，叶子节点有两个double类型的数据

  - 用结构体：

    ```c
    struct node_s {
    	struct node_s *left;
        struct node_s *right;
        double data[2];
    };
    ```

    - 每个节点需要32个字节

  - 用联合：

    ```c
    union node_u {
        struct {
            union node_u *left;
            union node_u *right;
        } internal;
        double data[2];
    };
    ```

    - 每个节点需要16个字节
    - 现在n是一个node_u* 类型的指针
      - 如果节点是内部节点，用n->internal.left引用内部节点的孩子
      - 如果节点是叶子节点，用n->data[0]引用叶子节点的数据
    - 存在的问题
      - 没办法根据节点本身的信息，确定这个节点是内部节点还是叶子节点

  - 改进后的联合：

    ```c
    typedef enum { N_LEFT, N_INTERNAL } nodetype_t;
    
    struct node_t {
        nodetype_t type;
        union {
            struct {
                struct node_t *left;
                struct node_t *right;
            } internal;
            double data[2];
        } info;
    };
    ```

    - 24字节

### 3.9.3 数据对齐

- 许多计算机系统会要求某种类型对象的地址比如是某个值（2、4或8）的倍数

## 3.10 在机器级程序中将控制与数据结合起来

- 目前为止，已经分别讨论机器级代码如何实现程序的控制部分和如何实现一些数据结构
- 本节会探讨数据和控制如何交互
  - 指针
  - GDB调试器
  - 机器级程序和缓冲区溢出
  - 动态的栈空间大小

### 3.10.1 理解指针

###

### 3.10.2 应用：使用GDB调试器

###

### 3.10.3 内存越界引用和缓冲区溢出

- C对数组引用不作任何检查，并且局部变量和状态信息（例如保存的寄器和返回地址）都在栈中
  - 因此一旦数组越界，就会覆盖掉这些在栈中的状态信息
- 缓冲区溢出的一个例子
  - 书上代码
  - 随着字符长度变化，信息被破坏的情况见书上表格
    - 有16字节的未被使用空间，为什么要留这个空间，防止溢出？？？
    - 长度再增大会破坏返回地址（回忆3.7.2的图3-26，调用别的过程时，先把返回地址压入栈）

- 缓冲区溢出的另一个例子
  - 让程序执行本来不愿意执行的函数
  - ###

### 3.10.4 对抗缓冲区溢出攻击

###

### 3.10.5 支持变长栈帧

###

## 3.11 浮点代码

###

