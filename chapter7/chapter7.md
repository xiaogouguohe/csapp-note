# 第7章 链接

- 链接是什么

  - 将各代码和数据片段收集并组合成单一文件的过程

  - 这个文件可以被加载到内存并执行

- 链接的时机

  - 可以执行于编译时，也就是代码被翻译成机器代码时
  - 可以执行于加载时，也就是程序被加载器加载到内存并执行时
  - 可以执行于运行时，也就是由应用程序来执行

- 执行链接的是链接器

- 链接器使得分离编译变得可能

  - 不用将大型应用程序组织为一个巨大的源文件，而是可以分解成各个模块
  - 当改变模块中的一个时，只需要简单地重新编译它，并重新链接

- 本章对链接进行全方位讨论

  - 链接的各个时机

  - 实际示例
  - 连接问题在哪些情况中会影响程序的性能和正确性

## 7.1 编译器驱动程序

- 图7-1是一个贯穿本章的运行示例
- 大多数编译系统编译器驱动程序
  - 在需要时调用语言预处理器、编译器、汇编器和链接器
  - 图7-2概括了驱动程序将图7-1的程序，从源文件翻译成可执行目标文件的行为
    - ###
    - 运行可执行文件prog
      - 调用操作系统中一个教加载器的函数，它把prog中的代码和数据复制到内存，然后把控制转移到这个程序的开头

## 7.2 静态链接

- 像Linux LD程序这样的静态链接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全连接的、可以加载和运行的可执行目标文件作为输出
  - 可重定位目标文件由不同的代码和数据节组成，每一个是一个连续的字节序列
  - 指令、初始化的全局变量、未初始化的变量在不同的节中
- 为了构造可执行文件，链接器必须完成两个主要任务
  - 符号解析？？？
    - 目标文件定义和引用符号
    - 每个符号对应于一个函数、一个全局变量或一个静态变量
    - 符号解析的目的是将每个符号引用和一个符号定义关联起来
  - 重定位
    - 编译器和汇编器生成从地址0开始的代码和数据节
    - ###
- 接下来的章节会更加详细地描述这些任务

## 7.3 目标文件

- 目标文件的三种形式
  - 可重定位目标文件
    - 包含二进制代码和数据
    - 在编译时与其它可重定位目标文件合并，创建一个可执行的目标文件
    - 由编译器和汇编器生成
  - 可执行目标文件
    - 包含二进制代码和数据
    - 可以被直接复制到内存并执行
    - 由链接器生成
  - 共享目标文件
    - 特殊类型的可重定位目标文件
    - 可以在加载或运行时被动态地加载进内存并链接

## 7.4 可重定位目标文件

- 图7-3展示了一个典型的ELF可重定位目标文件的格式
  - ELF头
    - ###
  - 节
    - .symtab：符号表，存放在程序中定义和医用的函数和全局变量的信息
    - ###

## 7.5 符号和符号表

### 7.5.1 链接器

- 本质上是一个程序
- 输入是编译器编译好的目标文件
- 输出是可执行文件或者库
- 链接器可操作的元素
  - 链接器可操作的最小元素是一个简单的目标文件
  - 所有应用程序（Windows的EXE文件，Linux的ELF文件），都是链接器将一个个目标文件汇集起来的

### 7.5.2 符号决议

- 链接器需要确保所有目标文件的符号引用都有唯一的定义

#### 7.5.2.1 C源文件都有什么

- 一个简单的C源文件（1.png）

  ![1](/home/xiaogouguohe/csapp-note/chapter7/1.png)

#### 7.5.2.2 目标文件里有什么

- 可以把目标文件理解为由两部分组成，如图（2.png）

  ![2](/home/xiaogouguohe/csapp-note/chapter7/2.png)

  - 代码段保存CPU可以执行的机器指令
    - 它们来自函数，编译器把函数翻译成机器指令，然后放到目标文件的代码段
  - 数据部分存放的是机器指令操作的数据
    - 局部变量只在函数内部使用，是机器指令的草所述，被放在代码段中

#### 7.5.2.3 符号表

- 编译器和链接器分别的工作

  - 编译器在编译过程中会在文件内部找变量或函数的定义，但如果遇到外部定义的全局变量或函数，只要能找到相应的声明，就会顺利编译
  - 链接器会寻找变量的唯一定义
  - 编译器为了让链接器的工作更加轻松，生成了一张符号表

- 上述示例代码的符号表如图（3.png）

  ![3](/home/xiaogouguohe/csapp-note/chapter7/3.png)

- 符号表要表达的关键内容

  - 自己能提供给其它文件使用的符号

  - 自己需要其它文件给自己使用的符号

- 符号表放在什么地方

  - 在目标文件里，除了数据段和代码段，还有符号表

- 符号决议的过程

  - 找声明的变量在其它目标文件中的定义

  - 新学期开学后，幼儿园的小朋友们都带了礼物要和其它的小朋友们分享，同时每个小朋友也有自己的心愿单，每个小朋友都可以依照自己的心愿单去其它的小朋友那里拿礼物，整个过程结束后，每个小朋友都能拿到自己想要的礼物。在这个游戏当中，小朋友就好比目标文件，每个小朋友自己带的礼物就好比每个目标文件的已定义符号集合，心愿单就好比每个目标文件中未定义符号的集合

    ![4](/home/xiaogouguohe/csapp-note/chapter7/4.png)

- 实例说明undefined reference

  - 现在，有一个math.c的程序，其中定义了一个add函数，该函数在main.c被引用到，如图（5.png）

    ![5](/home/xiaogouguohe/csapp-note/chapter7/5.png)

  - 不小心注释掉math.c的add函数，如图（6.png）

    ![6](/home/xiaogouguohe/csapp-note/chapter7/6.png)

  - 报错产生的原因
    - 链接器发现math.o引用了外部定义的add函数（通过检查math.o中的符号表），然后开始查找add的定义
    - 链接器去其它目标文件的符号表中找add函数的定义，没有找到
    - 查找了所有目标文件的符号表，都没有找到add函数的定义，因此报错
  - 排查步骤
    - main.c中对add函数的函数名有没有写正确
    - 链接命令中有没有包含math.o，如果没有添加上该目标文件
    - 如果链接命令没有问题，查看math.c中定义的add函数定义是否有问题
    - 如果是C和C++混合编程时，确保相应的位置添加了extern "C"

## 7.6 符号解析

- 链接器解析符号引用，就是将每个引用（比如函数调用），与输入的可重定位目标文件的符号表（见图3.png）中的一个确定的符号定义，一一对应
  - 对于那些定义和引用在同一个模块的情况，解析很简单
    - 编译器只允许每个模块的每个局部符号有且只有一个定义
    - 静态变量也会有符号，而且编译器确保它们 的名字唯一
  - 对全局符号的引用解析，需要查找别的可重定位目标文件的符号表（图4.png）

### 7.6.1 链接器如何解析多重定义的全局符号

- 主要解决多个模块定义同名的全局符号的情况
- 强弱规则
  - 函数和已初始化的全局变量是强符号
  - 未初始化的全局变量是弱符号
- 处理多重定义的规则
  - 规则1：不允许有多个同名的强符号
  - 规则2：如果有一个强符号和多个弱符号同名，选择强符号
  - 规则3：如果有多个弱符号同名，任意选择一个
- 规则2和3可能导致意料之外的行为

### 7.6.2 与静态库链接

- 静态库
  - 之前都是假设链接器读取一组可重定位目标文件，并把它们连接起来，输出一个可执行文件
  - 实际上，可以把所有相关的目标模块打包成一个单独的文件，称为静态库，作为链接器的输入

  - 当链接器构造输出的可执行文件时，只复制静态库里被应用程序引用的目标模块

- 为什么要支持静态库

  - 以ISO C99为例，它定义了atoi、printf、scanf之类的函数，在libc.a库中，对每个C程序来说都是可用的

  - 如果不使用静态库，可以怎么用到这些函数

    - 让编译器辨认出对标准函数的调用，并直接生成相应代码？？？
      - Pascal的做法就是这样的
      - C有大量标准函数，这样做对编译器要求太高，且每次改动一个标准函数，就需要一个新的编译器版本，不现实
    - 把所有的标准C库函数都放在一个单独的可重定位目标模块中
      - 优点是，编译器的实现和标准函数的实现不再具有相关性
      - 但是每个可执行文件都要包含一份标准函数的可重定位目标文件的副本，占用空间
      - 对标准函数的任何改变，都要重新编译整个标准函数的所有源文件
    - 为每个标准函数都创建一个独立的可重定位文件
      - 对程序员极度不友好，需要gcc编译时要显式添加用到的模块

  - 静态库用来解决这些方法的缺点，以图7-6为例

    - 对代码的解释
      - 这个例子实现了两个运算，分别对两个向量x和y进行向量的加法和点积运算，运算结果放在向量z当中
      - 每次调用把全局变量加1（作用见7.12）

    - 创建这两个函数的静态库
    - 图7-7用到了addvec函数，那么只会把addvec模块复制一份副本到最后的可执行文件，不会复制mulvec模块

  - Linux系统中，静态库以一种称为存档的特殊文件格式存放在磁盘中

    - 存档文件是一组连接起来的可重定位目标文件的集合
    - 有一个头部用来描述每个成员目标文件的大小和位置
    - 存档文件名由后缀.a标识

### 7.6.3 链接器如何使用静态库来解析引用

- 符号解析阶段，链接器从左到右，按照命令行上出现的顺序，扫描可重定位目标文件和存档文件

  - 驱动程序会把命令行中所有的.c文件翻译成.o文件

- 链接器维护的一些数据结构

  - 可重定位目标文件的集合E，这个集合的文件会被合并起来形成可执行文件

  - 未解析的符号的集合U，保存引用了但是未定义的符号
  - 在前面的输入文件中已经定义的符号的集合D

- 解析引用的工作流程

  - 初始时，E、U和D均为空
  - 对于每个输入文件f，链接器会判断f是一个目标文件还是一个存档文件
    - 如果f是一个目标文件，就把f添加到E，并相应地修改U和D（7.5.2.3），然后继续下一个输入文件
    - 如果f是一个存档文件，链接器会尝试用自己定义了的符号，去匹配U中未解析的符号
      - f中有若干目标文件，对于每个目标文件m，可能定义了一个符号，并且这个符号解析了U中的一个引用，那么需要把m添加到集合E中；否则丢弃m（这也就是为什么图7-7中，不需要链接mulvec）
    - 如果当链接器完成扫描后，U是非空的，链接器就会输出错误并终止。否则，它会合并和重定位E中的目标文件，构建输出的可执行文件

- 这种算法会导致一些令人困扰的链接时错误

  - 库和目标文件的顺序非常重要，例如

    ```bash
    linux> gcc -static ./libvector.a main2.c
    
    /tmp/cc9XH6Rp.o: In function 'main':
    /tmp/cc9XH6Rp.o(.test+0x18): undefined reference to 'addvec'
    ```

    在处理libvector.a时，U是空的，所以libvector.a的任何成员目标文件都不会被添加到E中，因此对addvec的引用是不会被解析的，导致错误

  - 一般把库放到命令行的结尾

    - 如果各个库之间也是没有依赖关系的，那么可以按照任何熟悉排列这些库

    - 如果库之间不是独立的，就需要排序，

      - 例如foo.c调用libx.a和libz.a，而这两个库又调用liby.a，那么应该这么写

        ```bash
        linux> gcc foo.c libx.a libz.a liby.a
        ```

      - 可以在命令行上重复库，例如，foo.c调用libx.a的函数，libx.a调用liby.a的函数，liby.a调用libx.a的函数，可以这样写

        ```bash
        linux> gcc foo.c libx.a liby.a libx.a
        ```

## 7.7 重定位

### 7.7.1 什么是重定位

- 例如，在C语言中，对一个全局变量g_num不断自增，对应的汇编指令可以是

  ```x86arm
  // g_num这个全局变量的内存地址就是0x400fda
  mov 0x400fda %eax
  add $0x1 %eax
  ```

- 可执行文件的代码和数据的运行时内存地址（0x400fda）是链接器指定的，确定这些地址的过程就是重定位

  - 注意这里的汇编指令，是链接器生成可执行文件后转汇编的，不是用户自己写的汇编指令？？？

### 7.7.2 为什么要重定位

- 确定可执行文件中代码和数据的运行时地址分为两个阶段
  - 汇编器阶段
  - 链接器阶段
- 汇编器在将源文件生成可重定位目标文件时，会定义该源文件中函数和全局变量的内存地址
  - 内存地址是相对地址，因为不知道要和其它哪些目标文件进行链接，生成最后的可执行文件，所以只生成相对地址
  - 对于在当前代码中引用，定义在其它源文件中的变量，编译器无法确定其内存地址
- 以上工作只能交给链接器完成，来确定运行时的内存地址

### 7.2.3 重定位的工作流程

- 重定位由两步构成
  - 重定位节和符号定义
  - 重定位节中的符号引用

#### 7.2.3.1 重定位节和符号定义

- 链接器将所有相同类型的节合并为同一类型的新的聚合节

  ![7](/home/xiaogouguohe/csapp-note/chapter7/7.png)

#### 7.2.3.2 重定位符号引用

- ###

## 7.8 可执行目标文件

- 一个典型的ELF可执行文件中的各类信息见图7-13

## 7.9 加载可执行目标文件

### 7.9.1 加载

- 运行可执行目标文件，可以在命令行输入

  ```bash
  linux> ./prog
  ```

- prog不是内置的shell命令，因此shell会认为prog是一个可执行目标文件，通过被称为加载器的操作系统代码来运行它
  - Linux程序可以通过调用execve函数来调用加载器（8.4.6）
- 加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的入口点（第一条指令）来运行该程序需，这个过程叫做加载
- 更具体的加载器工作流程设计进程、虚拟内存和内存映射的概念，在第8章和第9章

### 7.9.2 运行时内存映像（图7-15）

- 代码段从0x400000开始
- 后面是数据段
- 再后面是运行时对，通过调用malloc网上增长（9.9）
- 堆后面的区域为共享模块保留
- 用户站从最大的合法用户地址开始（2<sup>48</sup>-1）开始，向较小内存地址增长
- 栈上的区域，从地址2<sup>48</sup>开始，是为内核中的代码和数据保留的，也就是操作系统驻留在内存的部分

## 7.10 动态链接共享库

### 7.10.1 静态库的一些缺点

- 假如静态库有更新，那么想用这个库的最新版本，就需要显式地把程序与更新了的库重新链接
- 有些函数，例如标准I/O函数，在运行时会把这些函数的代码复制到每个运行进程的文本段中，浪费内存
  - 注意7.6.2中的另外一种使用库函数的方法，把所有库函数放在一个可重定位目标模块中，它更加浪费内存，因为每个运行进程都需要一份整个库函数的副本；而现在这种只需要使用到的库函数的副本，但是有些库函数经常被使用，所以会有多份这些函数的副本，依然浪费内存

### 7.10.2 共享库（动态库）

- 致力于解决静态库缺陷

- 共享库如何实现“共享”

  - 一个库只有一个.so文件，所有引用该库的可执行目标文件共享这个.so文件的代码和数据

    - 可执行文件需要包含共享库的信息，能通过这个信息找到共享库

  - 在内存中，一个共享库的节可以被不同的进程共享（见第9章的虚拟内存）

  - 用两张图说明静态库和共享库在内存上的区别

    - 静态库

      ![8](/home/xiaogouguohe/csapp-note/chapter7/8.png)

    - 共享库

      ![9](/home/xiaogouguohe/csapp-note/chapter7/9.png)

- 链接的时机

  - 加载或运行时会把可执行文件和动态库进行动态链接
    - 注意和静态链接区分开，静态链接是在生成可执行文件时就链接
    - 加载时动态链接和运行时动态链接见7.11

## 7.11 从应用程序中加载和链接共享库

### 7.11.1 动态链接可以在两种情况下被链接使用

- 加载时动态链接
  - 在命令行链接生成可执行文件时，需要将使用的动态库加入到链接选项中
    - 注意和静态链接的区别，见图8.png和图9.png
  - 在命令行执行这个可执行文件，把可执行文件加载到内存后，且在程序开始运行前，操作系统依据可执行文件的动态库信息，查找动态库并进行符号决议
- 运行时动态链接
  - 生成的可执行文件中没有任何关于动态库的信息
  - 程序员显式进行动态链接，运行时根据代码的行为进行链接
  - Linux提供了和动态链接相关的接口
    - 使用例子见7-17

### 7.11.2 动态链接下的可执行文件的结构

- 在之前对可执行文件的讨论的基础上，新增两段，如图10.png

  ![10](/home/xiaogouguohe/csapp-note/chapter7/10.png)

  - 两个段的作用###

## 7.12 位置无关代码

### 

## 7.13 库打桩机制

###

## 7.14 处理目标文件的工具

###

