# 第4章 处理器体系结构

- 一个处理器支持的指令和指令的字节级编码称为它的指令集体系结构（ISA）
  - 处理器有很多，各自有不同的ISA
  - ISA为编译器编写和处理器设计之间提供了抽象层？？？
    - 编译器编写只需要知道允许哪些指令，以及它们如何编码
    - 处理器设计者要造出这些指令的处理器

- 现代处理器的实际工作方式和ISA隐含的计算模型大相径庭
  - ISA看上去是顺序指令执行
  - 同时处理多条指令，处理器的性能更高
- 本章使用的指令集Y86-64
  - 受x86-64的启发，更简单
- HCL，硬件控制语言
- 设计处理器的思路
  - 顺序操作的处理器
    - 功能正确
    - 时钟周期要足够慢，才能确保一个周期内执行完一条指令，因此性能差
  - 流水线化的处理器
    - 每条指令的执行分解成五步，每个步骤由一个独立的阶段（硬件部分）来处理，因此处理器可以同时执行五条指令的不同阶段
    - 为了保证顺序行为，需要处理冒险情况
      - 冒险是指一条指令的位置或者操作数依赖于其他仍在流水线中的指令

## 4.1 Y86-64指令集体系结构

- 一个指令集体系结构包括定义各种状态单元、指令集和它们的编码、一组编程规范和异常事件处理

### 4.1.1 程序员可见的状态

- 程序员可见状态
  - 指令会读取或修改处理器状态的某些部分
  - 这部分被称为程序员可见状态
  - 程序员可以指写汇编代码的人，也可以是产生机器级代码的编译器
- Y86-64的状态类似于x86-64
  - 15个程序寄存器（少了%r15）
    - 每个程序寄存器64位
    - %rsp用作栈指针
    - 其它寄存器没有固定的含义或值
  - 3个1位的条件码
  - 程序计数器存放当前正在执行的指令的地址
  - 内存
  - 状态码Stat
    - 指示正常还是异常
    - 4.1.4

### 4.1.2 Y86-64指令

- “字”都是8字节数据

- 见图4-2
- ###

### 4.1.3 指令编码

- 图4-2，每条指令需要1~10个字节

  - 第一个字节表明指令的类型

    - 高4位是代码部分
      - 值从0~0xB
    - 低4位是功能部分
      - 只有在一组相关指令共用一个代码时才有用

  - 有些指令只有一字节长，例如halt指令和nop指令

  - 有些指令有附加的寄存器指示符字节

    - 寄存器提示符字节指定一到两个寄存器，分别记为rA和rB
    - 可以指定用于数据源和目的的寄存器，或者用于地址计算的基址寄存器
    - 没有寄存器操作数的指令（如call指令和分支指令），就没有寄存器提示符字节
    - 只有一个寄存器操作数的指令（如irmovq、pushq和popq）把另一个寄存器提示符设为0xF

  - 有些指令需要一个附加的4字节常数字（长度却是8字节？？？）

    - 使用场景

      - irmovq的立即数数据
      - rmmovq和mrmovq的地址提示符的偏移量
      - 分支指令和调用指令的目的地址

    - 例子：用十六进制表示以下指令

      ```x86arm
      rmmovq %rsp, 0x123456789abcd(%rdx)
      ```

      - 如图4-2，第一个字节（）为0x40
      - 源寄存器%rsp编码在rA字段，基址寄存器%rdx编码在rB字段，根据图4-4，第二个字节（寄存器提示符字节）为0x42
      - 偏移量编码在8字节的常数字中（注意填充和小端）

### 4.1.4 Y86-64异常

- 状态码见图4-5
- 对异常情况的处理
  - 在Y86-64中，直接停止执行指令
  - 一般的处理器设计中，会调用一个异常处理程序

### 4.1.5 Y86-64程序

###

### 4.1.6 一些Y86-64指令的详情

- pushq %rsp和popq %rsp
  - 不确定的行为，以pushq %rsp为例
    - 到底是先把%rsp的值入栈，再对%rsp的值减8
    - 还是反过来
  - 具体行为是怎么样，见练习题4.7和4.8

## 4.2 逻辑设计和硬件控制语言HCL

- 一个数字系统包括三个主要的组成部分
  - 计算对位进行操作的函数的组合逻辑
  - 存储位的存储器单元
  - 控制存储器单元更新的时钟信号
- 介绍HCL，来描述不同处理器设计的控制逻辑
  - 完整参考见网络旁注ARCH:HCL

### 4.2.1 逻辑门

###

### 4.2.2 组合电路和HCL布尔表达式

- 组合电路的限制规则
  - 每个逻辑门的输入必须连接到下列之一
    - 系统输入（主输入）
    - 某个存储器单元的输出
    - 某个逻辑门的输出
  - 两个以上的逻辑门的输出不能连在一起
  - 网无环
- 组合电路的一个例子见图4-10
- 组合逻辑电路和C语言逻辑表达式的比较
  - 都是用布尔操作来对输入进行计算的函数
  - 有以下区别
    - ###

### 4.2.3 字级的组合电路和HCL整数表达式

- 字级组合电路的一个例子见图4-13	
  - s输入为1时，输出为A，否则输出为B
  - 图4-13a具体到每个逻辑门，图4-13b为抽象之后的组合电路

- 选择表达式和C的switch

  - 选择表达式之间不一定要互斥，因为是顺序求值，第一个值为1的表达式会被选中

  - 如图4-13的例子用HCL来描述就是

    ```verilog
    word Out = [
        s: A;
        1: B;
    ];
    ```

- ###

### 4.2.4 集合关系

- 见书上例子

### 4.2.5 存储器和时钟

- 组合电路不存储任何信息，只是响应输入信号，产生相应的输出

- 为了产生时序电路，引入按位存储信息的设备

  - 时序电路是有状态并且在这个状态上进行计算的系统，因此需要存储之前的状态，才能计算

  - 存储设备是由同一个时钟控制的
    - 时钟是一个周期性信号，决定什么时候把新值加载到设备中
    - 两类存储器设备
      - 时钟寄存器（寄存器）
        - 存储单个位或字
      - 随机访问存储器（内存）
        - 存储多个字，用地址来选择该访问哪个字
        - 随机访问存储器的例子
          - 处理器的虚拟内存系统
          - 寄存器文件
            - 更具体的讨论见本节4.2.5后面的内容
    - 注意区分时钟寄存器和程序寄存器，不是同一个概念

- 在硬件和机器级编程中，“寄存器”是有差别的
  - 在硬件中，寄存器直接把它的输入和输出线连接到电路其他部分
  - 在机器级编程中，寄存器代表的是CPU中为数不多的可寻址的字，这里的地址是寄存器ID，也就是说通过寄存器ID来访问某个确定的寄存器
- 图4-16说明了硬件寄存器是如何工作的
  - 大多数时候寄存器保持稳定状态x，产生的输出等于它的当前状态
  - 信号沿着寄存器前面的组合逻辑传播
  - 某个时候会有新的寄存器输入y，但只要时钟是低电位的，寄存器输出就保持不变
  - 当时钟变成高电位时，输入信号y加载到寄存器中，这个就是新输出y
  - 也就是说，寄存器是电路中不同部分的组合逻辑的屏障，只有时钟到上升沿时，值才会从寄存器的输入传送到输出
  - Y86-64处理器用时钟寄存器保存程序计数器、条件代码和程序状态
- 寄存器文件
  - 若干个寄存器组成的寄存器阵列，在Y86~64这里是%rax~%r14组成
  - 通过寄存器ID（也称为地址）访问到某个具体的寄存器，ID就是%rax这些
  - 寄存器文件的图
    - 内部结构在本节内容暂时不用关心
    - 两个读端口和一个写端口
    - 一次读或者写经历了什么
      - 当读端口srcA被设为3时，每次时钟上升时，存储在%rbx的值就会出现在valA上
      - 当写端口dstW被设为3时，每次时钟上升时，输入valW的值会被写入%rbx
      - 如果同时读和写%rbx，将会在读端口上看到一个从旧值到新值的变化
- 处理器有一个随机访问存储器来存储程序数据
  - ###

## 4.3 Y86-64的顺序实现

- 描述一个SEQ（顺序）处理器
  - 每个时钟周期处理一条完整指令
  - 性能差，因此最终目标是要流水线

### 4.3.1 将处理组织成阶段

- 一条指令包括多条操作，但是都遵循统一的序列

  - 取值

    - 从内存读取指令字节，内存地址为程序计数器（PC）的值

    - 读取到指令后，取出指令提示符字节（第一个字节，见4.1.3），由两个四位部分组成，分别是icode（指令代码）和ifun（指令功能）

    - 接下来的字节

      - 可能是一个提示符字节，指明一个或两个寄存器操作数提示符rA和rB（15个程序寄存器，因此只需要4位表示，一个字节可以表示两个寄存器）

      - 也可能是一个常数字valC（长度8字节）

    - 如何得到下一条指令

      - 指令是顺序存储的
      - 下一条指令的地址valP，等于PC的值加上已取出指令的长度

  - 译码

    - 从寄存器文件读最多两个操作数（也可能没有寄存器操作数），得到valA和/或valB
      - 一般是读指令的rA和rB字段指明的寄存器
      - 也有些指令是读%rsp的

  - 执行

    - ALU要么执行指令说明的操作（根据ifun），来计算内存引用的有效地址；要么增减栈指针
    - 得到的值称为valE
    - 可能会设置条件码
      - ###

  - 访存

    - 把数据写入内存，或者从内存读出数据，读出的值为valM

  - 写回

    - 最多写两个结果到寄存器文件

  - 更新PC

    - 把PC设置成下一条指令的地址

- 图4-18中rrmovq rA, rB的执行

  - 取指
    - icode和ifun是第一个字节
    - rA和rB是第二个字节
    - 指令长度为两个字节，因此下一条指令的地址是这一条+2
  - 译码
    - 从寄存器文件读出来rA的值
  - 执行
    - 得到valE
  - 访存
    - 这里不用访问内存
  - 写回
    - 把valE写回到寄存器rB
  - 更新PC

- 其它指令的执行例子

  - ###

### 4.3.2 SEQ硬件结构

- 硬件结构见图4-22和图4-23
- ###

### 4.3.3 SEQ的时序

- 一条指令执行的“顺序”模型和实际的差别
  - 一条指令的取址、译码等操作是顺序执行的
  - 实际上，如图4-23，一个时钟变化会引发一个经过组合逻辑的流，来执行整个指令
  - 这两者的区别在哪？？？
  
- 为了保证等价性，需要遵循“从不回读”的原则

  - 处理器从来不需要为了完成一条指令的执行，去读由该指令更新了的状态
  - 一个例子：pushq指令的实现
    - 如果是先将%rsp减8，再把这个新的%rsp值作为写操作的地址去写内存，就违反了“从不回读”原则，因为这条指令去读了它更新的%rsp状态
    - 而如果按照图4-20的做法，先把%rsp的值减8赋给valE（执行），然后把valE作为写内存的地址（访存）和写寄存器的数据（写回），那么在时钟上升开始下一个周期时，就可以同时执行寄存器写和内存写了

  - 另一个例子：条件码
    - ###

### 4.3.4 SEQ阶段的实现

- 本节会设计实现SEQ所需要的控制逻辑块的HCL描述
- HCL描述中常用的常数值见图4-26
- 硬件图的一些画图惯例
  - 白色方框表示时钟寄存器，这里只有PC
  - 浅蓝色方框表示硬件单元，如内存、ALU等，视为黑盒
  - 灰色圆角矩形表示控制逻辑块，可以用HCL描述
  - 白色圆圈中说明线路的名字
  - 中等粗的线表示宽度为字长的数据连接（64根）
  - 细线表示宽度为字节或更窄的数据连接（4或8根）
  - 虚线表示单个位的连接
- 注意和图4-18~4-21联系

#### 4.3.4.1 取指阶段

- 硬件图见图4-27

- 以PC作为起始地址，从指令内存读出10个字节

- 第一个字节被解释为指令字节

  - 被Split单元分为两个4位的数

  - icode和ifun的控制逻辑块

  - 三个标志位

    - instr_valid：这个字节是否对应于一个合法的Y86-64指令

    - need_regids：这个指令是否包含一个寄存器指示符字节

      - HCL实现见书上

    - need_valC：这个指令是否包含一个常数字

      - HCL实现如下（练习题4.19）

        ```verilog
        bool need_valC = icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL }; # 枚举所有有常数字的指令
        ```

- 剩下9个字节是寄存器指示符字节和常数字的组合编码
  - Align单元处理这些字节
    - 根据need_regids标志位，产生rA、rB和valC
- 根据当前PC和两个信号need_regids、need_valC，产生信号valP（也就是计算当前指令的长度）

#### 4.3.4.2 译码和写回阶段

- 硬件图见图4-28

- 把这两个阶段放在一起是因为它们都要访问寄存器文件

  - 译码是根据指令的rA和rB部分，从寄存器取值valA和valB
  - 写回是根据valE，写寄存器

- 寄存器文件的四个端口

  - 两个读（A和B），两个写（E和M）

  - 每个端口有一个地址连接和一个数据连接

    - 地址连接是一个4位寄存器ID（指明访问哪个寄存器），数据连接是一组64根线路，图中地址连接是dstX、srcX，数据连接是valX
    - 数据连接是读端口的输出字（从srcX读出来寄存器值，通过valX输出），是写端口的输入字（把valX写入dstX指明的寄存器）
    - 如果某个地址端口上的值为0xF，表明不需要访问寄存器

  - 如何根据icode和rA得到srcA

    ```verilog
    word srcA = [
        // 见图4-18~4-21，译码的第一行
        icode in { IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ } : rA; 
        icode in { IPOPQ, IRET } : RRSP // 这些都是对栈指针的操作，因此读的是栈指针
        1 : RNONE; // 其余视为没有寄存器操作数
    ];
    ```

  - 如何根据icode和rB得到srcB（习题4.20）

    ```verilog
    word srcB = [
        // 见图4-18~4-21，译码的第二行
        icode in { IRMMOVQ, IMRMOVQ, IOPQ } : rB;
        icode in { IPOPQ, IPUSH, ICALL, IRET } : RRSP;
        1 : RNONE;
    ];
    ```

  - 如何得到dstE

    - 见图4-18~4-21，写回的第一行
    - 书上的结果是忽略了条件移动指令，在执行阶段会看看如何实现条件传送

  - 如何得到dstM

    - 见图4-18~4-21，写回的第二行

#### 4.3.4.3 执行阶段

- ALU单元根据alufun信号（？？？）的设置，对输入aluA和aluB执行ADD、SUBTRACT、AND或EXCLUSIVE-OR运算，输出为valE信号

  - 列出的操作数，aluB在前面，aluA在后面

  - aluA的值可以是valA、valC（立即数），或者是+8、-8，用HCL表示产生aluA的控制块的行为见书上word aluA

  - ALU通常作为加法器使用，不过对于OPq指令，希望它使用指令的ifun字段中编码的操作，因此ALU控制的HCL描述见书上

    - 如果icode是IOPQ，说明该指令是OPq操作，ALU的行为由指令的ifun字段来控制

    - 其余的情况，ALU执行ADD操作就可以了
      - 例如rrmovq操作，经过ALU，rA + 0即可（没有偏移量）

- 条件码寄存器

  - 每次运行时，ALU都会产生三个和条件码相关的信号——零、符号和溢出

  - 期望只在执行OPq指令时才设置条件码，因此产生了一个信号set_cc来控制是否更新条件码寄存器

  - 用HCL来表示可以写成这样

    ```verilog
    bool set_cc = icode in { IOPQ };
    ```

#### 4.3.4.4 访存阶段

###

#### 4.3.4.5 更新PC

###

#### 4.3.4.6 SEQ小结

- 通过不同的硬件单元和一个时钟来实现整个处理器
- 太慢了
  - 为什么慢：每个单元只在整个时钟周期的一部分时间内被使用，因此可以想办法更充分地利用硬件单元
  - 解决：流水线

## 4.4 流水线的通用原理

- 自助餐厅的例子
- 提高了系统的吞吐量
- 轻微增加了延迟

### 4.4.1 计算流水线

- 和流水线相关的计算见图4-32和图4-33

### 4.4.2 流水线操作的详细说明

- 直到时钟上升时，输入才被加载到流水线寄存器中，成为寄存器的输出

- ###

### 4.4.3 流水线的局限性

- 一些因素会制约流水线的效率
  - 不一致的划分
    - 图4-36
  - 流水线过深，收益反而下降
    - 图4-37

### 4.4.4 带反馈的流水线系统

- 之前提到的系统，流水线的每个阶段都是相互独立的
- 但是对于执行机器程序的系统来说，相邻指令之间很可能是相关的
- 两个例子
- 如果不考虑这些相关性（反馈路径），那么会有图4-38的后果
  - 图4-38b中，未流水线化，如我们所期望的，I1的结果作为I2的输入
  - 图4-38d中，流水线化，本来I1的结果应该作为I2的输入，实际上却作为了I4的输入

## 4.5 Y86-64的流水线实现

- 对顺序处理的SEQ处理器做一些小改动
  - 把PC的计算挪到取址阶段
  - 在各个阶段之间加上流水线寄存器
  - 其它一些修改
- 实现流水线化的处理器

### 4.5.1 SEQ+：重新安排计算阶段

- 移动PC阶段，使得它的逻辑在时钟周期开始时活动（之前是在结束时）
  - 图4-39，状态寄存器，是哪些寄存器？？？
  - 图4-40
  - 为什么要这样改动？？？
- SEQ到SEQ+的改动是电路重定时的一个例子
  - 改变一个系统的状态表示，不改变它的逻辑行为

### 4.5.2 插入流水线寄存器

- 在SEQ+的各个阶段之间插入流水线寄存器，并对信号重新排列，得到PIPE-寄存器
  - '-'表示和最终的设计相比，性能差一点
  - 抽象结构如图4-41
  - 和SEQ+的硬件单元几乎一样，只是引入了流水线寄存器分隔开这些阶段
  - 寄存器流水线有哪些，F D E M W

### 4.5.3 对信号进行重新排列和标号

- 顺序实现的设计中，在一个时刻只处理一条指令，因此valC、srcA和valE这样的信号具有唯一值
- 流水线设计中，同一时刻，与各个指令相关的值有多个版本，
  - 在PIPE-结构中，有4个标号为"Stat"的白色方框，保存着4条不同指令的状态码（图4-41）
- 采用一种命名机制
  - 在信号名前面加上大写的流水线寄存器名字作为前缀，来标识存储在流水线寄存器中的信号，如M_stat
  - 在信号名前面加上小写的阶段名的第一个字母作为前缀，来标识一个阶段内计算出来的信号，如m_stat
- 下面讨论SEQ+和PIPE-硬件上设计的不同 

#### 4.5.3.1 SEQ+和PIPE-的“写回”阶段执行的时机

- SEQ+和PIPE-的译码阶段都产生信号dstE和dstM，它们指明值valE和valM的目的寄存器
- 在SEQ+中，可以把这些信号直接连到寄存器文件写端口的地址输入
- 在PIPE-中，会在流水线一直携带这些信号穿过执行和访存阶段，直到写回阶段才送到寄存器文件
  - 如果像SEQ+那样直接连到寄存器文件，这个时候写回阶段可能在写入另一条指令，而寄存器ID却来自译码阶段的指令，也就是说寄存器ID和写入的值不是来自同一条指令

#### 4.5.3.2 "select A"块

- 在译码阶段
- 在流水线寄存器D的valP和寄存器文件A端口独处的值valA中选择一个
- 这个块是为了减少要携带给流水线寄存器E和M的数量
  - 只有以下指令和阶段需要用到valP的值
    - call指令在访存阶段
      - 图4-21
    - 跳转指令在执行阶段（当不需要跳转时）
      - 图4-21
  - 上面提到的指令又不需要从寄存器文件中读出的值
  - 因此可以合并这两个信号，来减少流水线寄存器的状态数量
- 这样的处理，消除了SEQ（图4-23）和SEQ+（图4-40）中标号为"Data"的块

#### 4.5.3.3 状态码stat字段

- 取指阶段被计算出来，访存阶段可能会被修改
- 4.5.6讨论如何实现异常事件的处理
- 比较系统的方法是让每条指令相关的状态码和指令一起通过流水线

### 4.5.4 预测下一个PC

- 为什么要预测下一个PC
  - 流水线设计的目的就是每个时钟周期都发射一条新指令，因此要做到这个时钟周期内找到下一条指令
  - 有些指令没法做到在这个周期内找到下一条指令
    - 条件分支指令要通过执行阶段之后，才知道是否要选择条件分支
    - ret指令要通过访存阶段才能确定返回地址
    - 其余指令都能够在这个周期内确定下一条指令的地址
      - 对call和jmp指令来说，下一条指令的地址是指令中的常数字valC
      - 对于其它指令来说是valP
- 如何预测

  - 一般是对分支指令进行预测
    - 这里的设计总是预测选择了条件分支
    - 也有其它的分支预测策略
  - ret指令不作预测
    - 返回地址是位于栈顶的字，可能性几乎是无限的
    - 处理办法是，直接暂停新指令，直到ret指令通过写回阶段（4.5.8）
- 无论如何预测，都需要处理预测错误的情况（4.5.8）

- 取指阶段负责预测PC的下一个值（图4-41底部），以及为取指选择实际的PC
  - "predict PC"块会从PC增加器计算出的valP和取出的指令中得到的valC中进行选择
    - 顺序执行的情况下，指令内存中的下一条指令，就是要执行的指令，这个时候用到PC增加当前指令的长度
    - 跳转指令的valC是需要跳转到的指令在内存中的地址，这个时候用到valC
    - 选择出来的值存放在流水线寄存器F中，作为PC的预测值
  - "select PC"的块类似于SEQ+的PC选择阶段中标号为"PC"的块（图4-40），从三个值中选择一个作为指令内存的地址
    - 预测的PC
    - 对于到达流水线寄存器M的不选择分支的指令来说是valP的值（存储在寄存器M_valA中）
    - 当ret指令到达流水线寄存器W（存储在W_valM）时的返回地址的值
    - 这个时候选还来得及吗，想要的应该是上一条指令的valP或者ret的返回地址，现在是前面若干条指令的？？？

### 4.5.5 流水线冒险

- 回忆4.4.4，将流水线引入一个带反馈的系统时，要考虑相邻指令之间的相关问题
  - 数据相关
    - 下一条指令用到这一条指令计算出的结果
  - 控制相关
    - 一条指令要确定下一条指令的位置，例如执行跳转、调用或者返回指令时
- 同相关一样，冒险也可以分为两类
  - 数据冒险
  - 控制冒险

#### 4.5.5.1 数据冒险的一些例子

- 一个没有数据冒险的例子，图4-43
  - 图中放大的是第二条irmovq指令的写回阶段和addq指令的译码阶段
  - 周期6中，第二条irmovq把结果3写入%rax；周期7中，addq读源操作数，读到的就是irmovq写入的值，符合我们的期望，因此没有数据冒险
- 一个数据冒险的例子，图4-44
  - 周期6中，第二条irmovq指令处于写回阶段，这个写要到周期7开始，时钟上升时，才会发生
  - 因此addq指令会读出来0而非3
- 其它数据冒险的例子，图4-45和图4-46

#### 4.5.5.2 数据冒险出现的条件

- 一条指令的操作数被它前面三条指令中的任意一条改变

- 因为流水线化的处理器在译码阶段从寄存器文件中读取操作数，在三个周期后的写回阶段才会把指令的结果写到寄存器文件
  - 指令B的操作数被前三条以内的指令A改变，则指令A还没来得及写回寄存器，就已经执行指令B，因此指令B读到的还是旧值

#### 4.5.5.3 冒险的类型

###

#### 4.5.5.4 冒险的解决办法

- 用暂停来避免数据冒险

- 用转发来避免数据冒险

  ？？？

- 