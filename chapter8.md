# 第8章 异常控制流

- 从给处理器加电，到断电为止，程序计数器假设一个值的序列a<sub>0</sub>, a<sub>1</sub>, ..., a<sub>n-1</sub>
  - 每个a<sub>k</sub> 是某个相应的指令I<sub>k</sub>的地址
  - 每次从a<sub>k</sub>到a<sub>k-1</sub>的过渡称为控制转移
  - 这样的控制转移序列叫做处理器的控制流
- 程序能处理的控制流
  - 一般都是“平滑的”控制流，每个I<sub>k</sub>和I<sub>k+1</sub>在内存中是相邻的
  - 就算有突变（也就是I<sub>k</sub>和I<sub>k+1</sub>不相邻），通常是由跳转、调用或返回这样的程序指令造成的
  - 这些不相邻的指令通常都是必要的，程序可以处理这样的突变
- 但是有一些系统状态的变化，不是被内部程序变量捕获的，也不一定和程序的执行相关
  - 程序向磁盘请求数据，然后休眠，指导被通知说数据就绪
  - 子进程终止时，父进程必须得到通知
- 现代系统通过使控制流发生突变，对这些情况做出反应
  - 这些突变称为异常控制流（ECF）
  - 异常控制流发生在计算机系统的各个层次
    - 硬件层
    - 操作系统层，内核通过上下文切换，将控制在进程之间转移
    - 应用层，进程之间可以收发信号，接收方会将控制转移到它的一个信号处理程序
- 理解异常控制流的必要性
  - ###

## 8.1 异常

- 异常是异常控制流的一种形式，一部分由硬件实现，一部分由软件实现
- 图8-1展示了异常的基本思想
  - 状态
    - 在这里，处理器状态被编码为若干位和信号
    - 当处理器状态中发生一个变化时，处理器正在执行某个当前指令I<sub>curr</sub>
  - 事件
    - 状态变化称为事件
    - 事件可能和当前指令的执行相关，如虚拟内存缺页、算术溢出，或除以零；也可能没有关系，如系统定时器产生的信号或I/O请求完成
  - 异常处理程序
    - 专门设计用来处理上述事件的操作系统子程序
    - 当处理器检测到事件发生时，会通过异常表，进行一个间接过程调用，到异常处理程序（8.1.1）
      - 处理器是如何检测事件的？？？
    - 当异常处理程序完成处理后，根据引起异常的事件类型，会发生以下情况的一种（8.1.2）
      - 将控制返回给I<sub>curr</sub>
      - 将控制返回给I<sub>next</sub>
      - 终止被中断的程序

### 8.1.1 异常处理

- 处理异常需要硬件和软件合作，因此要明确它们的分工
- 每种类型的异常都由一个唯一的非负异常号
  - 一些是由处理器设计者分配的，还有一些是操作系统内核分配的
    - 前者包括除以零、缺页、内存访问违例、断点、算术溢出等
    - 后者包括系统调用和来自外部I/O设备的信号
    - 内核是操作系统常驻内存的部分
- 异常表
  - 在系统启动时（开机），操作系统分配并初始化了一张称为异常表的跳转表，使得条目k包含异常k的处理程序的地址（图8-2）
  - 系统执行某个程序时，处理器检测到了一个事件，并且确定了相应的异常号k，执行间接过程调用，通过条目k，转到相应的处理程序
    - 图8-3展示了如何生成异常处理程序的首地址，通过异常表基址寄存器和异常号
    - 异常表放在哪里，内核中？
- 异常和过程调用的区别
  - 过程调用时，在跳转到处理程序前，处理器将返回地址压入栈中；根据异常的类型，返回地址是当前指令或下一条指令
  - 异常发生时，处理器会把额外的处理器状态压入栈中
    - 处理程序返回时，重新开始执行被中断的程序，需要这些状态
    - 如x86-64系统会将包含当前条件码的EFLAGS寄存器等内容压入栈中
  - 如果控制从用户程序转移到内核，所有这些项目都被压入内核栈而非用户栈，而异常都是要陷入内核的
  - 异常处理程序运行在内核模式下（8.2.4）

### 8.1.2 异常的类别

- 图8-4对异常的类别和它们的特性做了小结

#### 8.1.2.1 中断

- 中断是异步发生的，是来自处理器外部的I/O设备的信号的结果，而不是任何一条专门的指令造成的；其他的异常类型都是同步发生的，是执行当前指令的结果
- 图8-5描述了中断的处理
  - I/O设备通过向处理器芯片上的一个引脚发信号，并将异常号放到系统总线上，来触发中断
    - 异常号会和异常表的条目去匹配
    - 异常号表示了引起中断的设备
  - 在执行完当前指令后，处理器注意到中断引脚的电压变高了，就从系统总线读取异常号
  - 根据异常表，调用适当的中断处理程序
  - 处理程序返回到下一条指令，程序继续执行（行为上好像没发生过中断）

#### 8.1.2.2 陷阱和系统调用

- 陷阱是有意的异常，是执行一条指令的结果
  - 作用是在用户程序和内核之间提供接口（系统调用）
  - 处理器提供了syscall指令来像内核请求服务，例如read、fork、execve等等
- 图8-6描述了系统调用的处理
  - 类似于中断

- 系统调用和普通的函数调用
  - 程序员的角度来看，这两者一样
  - 普通函数运行在用户模式，系统调用运行在内核模式（8.2.4）

#### 8.1.2.3 故障

- 故障由错误引起，可能能被故障处理程序修正，- 图8-7

  - 如果能，处理完后返回引起故障的指令，重新执行
  - 否则，返回到内核中的abort例程，abort例程会终止应用程序

- 经典的故障示例：缺页异常

  - 指令引用一个虚拟地址，而对应的物理地址不在内存中，必须 从磁盘中取出时，就会发生缺页异常（第9章）
  - 缺页处理程序从磁盘加载适当的页面，然后返回引起故障的指令

  - 再次执行指令，此时物理页已经在内存中，指令可以正常运行

#### 8.1.2.4 终止

- 终止一般是硬件错误造成的结果，如DRAM或SRAM位被损坏
- 终止处理程序返回一个abort历程，abort终止应用程序

### 8.1.3 Linux/x86-64系统中的异常

- 图8-9展示了一些示例

#### 8.1.3.1 Linux/x86-64故障和终止

- 除法错误

  - 尝试除以0，或结果对于目标操作数太大的时候发生
  - 终止程序
  - 报错浮点异常(Floating expection)

- 一般保护故障

  - 程序引用未定义的虚拟内存区域，或者试图写一个只读的文本段
  - 终止程序

  - 报错段错误(Segmentation falutl)

- 缺页

  - 第9章

- 机器检查

  - 硬件错误
  - 终止程序

#### 8.1.3.2 Linux/x86-64系统调用

- 图8-10给出了常见的Linux系统调用

  - 每个系统调用都有唯一标识的整数号，对应到内核中跳转表的偏移量（和异常表类似）

- C语言级别上，syscall函数可以调用任何系统调用，不过没必要这样做，因为标准C库提供了相应的API

- 汇编级别上，syscall陷阱指令提供了系统调用

  - %rax包含系统调用号

  - 有6个寄存器，包含最多6个参数
  - 例子见图8-11

## 8.2 进程

- 进程给用户提供的抽象
  - 一个独立的逻辑控制流（指令），应用程序独占地使用处理器（8.2.1）
  - 一个私有的地址空间，应用程序独占地使用内存系统（8.2.3）
- 进程的经典定义
  - 晋城市一个执行中程序的实例
  - 每个程序都运行在某个进程的上下文中
  - 上下文是由程序正确运行所需的状态组成的，这些状态包括
    - 内存中的程序的代码和数据
    - 栈
    - 通用目的寄存器的内容
    - 程序计数器
    - 环境变量
    - 打开的文件描述符集
    - 进程表

### 8.2.1 逻辑控制流

- 进程给应用程序提供假象，好像它在独占地使用处理器
- 如果用调试器单步执行程序，会看到一系列的PC值
  - 这些值唯一对应于可执行目标文件中的指令，或者是运行时动态链接到程序的共享对象中的指令
  - 这个PC值的序列叫做逻辑控制流
- 图8-12展示了三个进程的逻辑控制流
  - 关键在于进程是轮流使用处理器的
  - 对于一个运行在某个进程的上下文中的程序，看起来好像是独占使用处理器
  - 如果精确测量，会发现一些指令的执行之间，CPU好像会周期性停顿
  - 继续执行，不改变程序内存位置，和寄存器内容（保证还原上下文）

### 8.2.2 并发流

- ###

### 8.2.3 私有地址空间

- 进程给应用程序提供假象，好像它在独占地使用系统地址空间
  - 进程为每个程序提供它自己的私有地址空间
  - 和这个空间中某个地址相关联的内存字节，不能被其它进程访问，这里体现私有性
  - 私有地址空间有通用的结构，见图8-13
  - 现在有很多个进程，每个进程都有自己的私有地址空间，但是映射到实际的物理内存会不会不够用？？？如果不够，是否需要切换？？？切换切出去的内容放在哪里，放在磁盘？？？

#### 8.2.4 用户模式和内核模式

- 处理器必须提供一种机制，来限制一个应用可以执行的指令，以及它可以访问的地址空间范围
  - 通过控制寄存器中的模式位来提供这种功能，设置了该模式位，说明进程运行在内核模式；否则运行在用户模式
- 用户模式做不了什么
  - 内核模式可以执行指令集中的任何指令，可以访问内存中的任何位置
  - 用户模式的进程不允许执行特权指令，也不允许直接引用内核区的代码和数据，必须通过系统调用
- 运行应用程序代码的进程，初始时是在用户模式中的， 切换为内核模式的唯一方法是通过异常
- Linux提供了/proc文件系统，来允许用户模式进程访问内核数据结构
  - ###

### 8.2.5 上下文切换

- 上下文的定义见8.2
- 内核对进程进行调度的时候，通过上下文切换的机制来将控制转移到新的进程
- 上下文切换包括以下步骤
  - 保存当前进程的上下文
    - 保存到磁盘？？？
  - 恢复要执行的进程的上下文
  - 将控制传递给这个新恢复的进程
- 可能发生上下文切换的场合
  - 内核执行系统调用的时候，可能发生上下文切换
    - 如read系统调用需要访问此盘，等待数据的这段时间里，内核可能会运行另外一个进程
    - sleep系统调用，显式让进程休眠
  - 中断可能引发上下文切换
    - 所有系统都会产生周期性定时器中断，每次中断时，内核就会判断当前进程已经运行足够长事件，并切换到新的进程

- 图8-14展示了进程A和B之间上下文切换的实例

## 8.3 系统调用错误处理

- 包装一下错误处理的逻辑，使得代码更简洁

## 8.4 进程控制

- 这一节描述和进程操作相关的函数

### 8.4.1 获取进程ID

- 每个进程都有唯一的进程ID（PID）

  ```c
  #include <sys/types.h>
  #include <unistd.h>
  
  /* 返回当前进程的pid */
  pid_t getpid(void);
  /* 返回父进程的pid */
  pid_t getppid(void);
  ```

### 8.4.2 创建和终止进程

- 进程总是处于下面的状态之一

  - 运行
    - 进程要么在CPU上执行，要么在等待被执行并最终会被内核调度
  - 停止
    - 进程被挂起，且不会被调度
    - 当收到SIGSTOP等信号时，进程停止，并保持停止直到收到SIGCONT信号才开始运行
      - 信号见8.5
  - 终止
    - 进程永远停止了
    - 导致终止的三种原因
      - 收到信号，且该信号的默认行为是终止进程
      - 从主程序（main）返回
      - 调用exit函数

- exit函数

  ```c
  #include <stdlib.h>
  
  /* 设置退出状态 */
  void exit(int status);
  ```

- fork函数
  
  - ###

### 8.4.3 回收子进程

- ###

### 8.4.4 让进程休眠

- ###

### 8.4.5 加载并运行程序

- execve函数的原型

  ```c
  #include <unistd.h>
  
  int execve(const char *filename, const char *argv[], const char *envp[]);
  ```

- 对参数的解释

  - execve函数加载并运行可执行文件filename
  - argv是可执行文件filename的参数
  - envp是环境变量

- 只有出现错误，例如找不到filename，execve才返回调用程序

- 参数列表的数据结构见图8-20

  - argv[0]是可执行目标文件的名字
  - envp指向一个指针数组，每个指针都指向一个环境变量字符串，每个字符串都是类似于"name=value"的键值对

- execve加载了filename之后，调用7.9描述的启动代码

  - 启动代码设置栈，并把控制传递给新程序的主函数

  - 新程序的主函数原型为

    ```c
    int main(int argc, char **argv, char **envp);
    ```

- 新程序的main函数开始执行时，用户栈的组织结构如图8-22，从栈底到栈顶

  - 参数和环境变量
  - 环境变量指针数组，每个指针指向一个环境变量字符串
  - argv[]数组，每个元素指向一个参数字符串
  - 系统启动函数libc_start_main的栈帧
  - main函数的栈帧

- 操作环境数组的函数

### 8.4.6 利用fork和execve运行程序

- Unix shell和Web服务器这样的程序大量使用了fork和execve函数

  - shell执行的是一系列的读/求值步骤，然后终止
  - 读步骤读取命令行
  - 求值步骤解析命令行，并运行程序

- 一个例子，见图8-23~图8-25

  ```c
  /* 图8-23 */
  int main() {
      while (1) {
          /* read from command line to string cmdline*/
          /* eval(cmdline) */
      }
  }
  ```

  ```c
  /* eval a command line */
  void eval(char *cmdline) {
      /* parse cmdline */
      /* 是否启动后台进程 */
      bg = parseline(cmdline, argv)
      
      /* 第一个参数是否是内置的shell命令*/
      if (first argv is a builtin command) {
          /* 子进程执行 */
          if ((pid = fork()) == 0) {
              execve(argv[0], argv)
          }
          
          /* 是否是后台进程，如果不是，则等待子进程执行完再回收；
              否则开始下一轮迭代，读取下一个命令行 */
          if (!bg) {
              waitpid;
          }
      }
      return;
  }
  ```

  - 这个简单的shell有缺陷，它不回收后台子进程。要解决这个问题就要使用信号

## 8.5 信号

- 在之前对异常控制流的学习中，讨论了

  - 硬软件如何合作以提供基本的底层异常机制

  - 操作系统如何利用异常来支持上下文切换

- 本节研究更高层的软件形式的异常，称为Linux信号

  - 允许进程和内核中断其它进程

- 图8-26展示了Linux支持的信号

- 已经有了异常，为什么还要有信号

  - 底层的硬件异常是由内核异常处理程序处理的，对用户进程是不可见的
  - 还需要一种机制，通知用户进程发生了这些异常
  - 例如，一个进程试图除以0，内核会给它发送SIGFPE信号

### 8.5.1 信号术语

- 传送一个信号到目的进程，由两个不同步骤组成

  - 发送信号（8.5.2）
    - 内核通过更新目的进程上下文的某种状态（可能是某个标志位），发送一个信号给目的进程
    - 发送信号的两种原因
      - 内核检测到系统时间，如除零错误或子进程终止
      - 一个进程调用了kill函数，显式要求内核发送一个信号给目的进程
    - 进程可以发送信号给自己
  - 接收信号（8.5.3）
    - 当目的进程被内核要求以某种方式对信号的发送做出反应时，它就接收了信号
    - 进程有很多种可以处理这个信号的方式
      - 忽略这个信号
      - 通过信号处理程序来捕获这个信号

- 信号处理程序的工作流程见图8-27

- 待处理信号

  - 一个发出而没有被接收的信号叫做待处理信号
    - 也就是从信号发出到信号接收这段时间的信号
  - 任何时刻，一种类型最多有一个待处理信号
    - 如果一个进程有一个类型为k的待处理信号，那么接下来发送到这个进程的同类型信号都会被丢弃

- 进程可以阻塞接收某种信号

  - 当一种信号被设置为阻塞的时候，别的进程向这个进程发送信号时，内核会替这个进程“阻塞”这个信号
    - 也就是说从这个进程的角度来看，什么事都没发生，此时这个信号是待处理信号
    - 直到进程取消对这种信号的阻塞

  - 阻塞信号相关的数据结构
    - 内核为每个进程在pending位向量中维护待处理信号的集合，也就是内核替这个进程“阻塞”了哪些信号
    - 在blocked位向量中维护被阻塞的信号集合，也就是这个进程设置了哪些信号作为阻塞信号
    - 有进程向这个进程发送类型为k的信号时，内核设置pending中的第k位；这个进程接收类型为k的信号时，内核消除pending中的第k位

### 8.5.2 发送信号

- Unix提供了很多向进程发送信号的机制，这些机制都是基于进程组的

#### 8.5.2.1 进程组

- 也可参考《Unix环境高级编程》（9.4）

- 每个进程都只属于一个进程组，进程组通过进程组ID唯一标识，可以通过以下方法获取进程组ID

  ```c
  #include <unistd.h>
  
  pid_t getpgrp(void);
  ```

- 默认地，子进程和父进程同属一个进程组，进程可以通过以下方法改变自己或其它进程的进程组

  ```c
  #include <unistd.h>
  
  int setpgid(pid_t pid, pid_t pgid);
  ```

  - 如果pid是0，就使用当前进程的pid

  - 如果pgid是0，就使用pid作为进程组ID

  - 例如，进程15213是调用进程，则

    ```c
    setpgid(0, 0)
    ```

    创建一个新的进程组，进程组ID是15213，并且把进程15213加入到这个进程组当中

- 8.5.2.2~8.5.2.5介绍几种发送信号的方式

#### 8.5.2.2 用/bin/kill程序发送信号

- ```bash
  # 发送信号9给进程15213
  linux> /bin/kill -9 15213
  ```

- ```bash
  # 发送信号9给进程组15213的每个进程
  linux> /bin/kill -9 -15213
  ```

#### 8.5.2.3 从键盘发送信号

- Unix shell使用作业来表示为一条命令行求值而创建的进程

- ```bash
  linux> ls | sort
  ```

  会创建一个由两个进程组成的前台作业

  - 这两个进程通过Unix管道连接起来
  - 一个运行ls程序，一个运行sort程序

- shell为每个作业创建一个独立的进程组

  - 进程组ID通常取自作业中父进程的一个，如图8-28

- 键盘输入的一些行为
  - 输入Ctrl+C会导致内核发送一个SIGINT信号到前台进程组的每个进程，默认情况下是终止前台作业
  - 输入Ctrl+Z会导致内核发送一个SIGTSTP信号到前台进程组的每个进程，默认情况下是挂起前台作业

#### 8.5.2.4 用kill函数发送信号

- 进程通过调用kill函数发送信号给其它进程

  ```c
  #include <sys/types.h>
  #include <signal.h>
  
  int kill(pid_t pid, int sig);
  ```

  - 如果pid大于0，则发送信号sig给进程pid
  - 如果pid等于0，则发送信号给调用进程所在进程组中的每个进程（包括调用进程自己）
  - 如果pid小于0，则发送信号给进程组-pid中的每个进程

- 使用的例子见图8-29

#### 8.5.2.5 用alarm函数发送信号

- 进程通过调用alarm函数向它自己发送SIGALRM信号

  ```c
  #include <unistd.h>
  
  unsigned int alarm(unsigned int secs);
  ```

  - 内核在secs秒后发送一个SIGALRM信号给调用进程
  - 如果secs为0，那么不会调度新的闹钟？？？
  - 会取消任何待处理的闹钟

  - 返回前一次闹钟剩余的秒数，若没有任何待处理的闹钟，则返回0

### 8.5.3 接收信号

- 当内核把进程p从内核模式切换到用户模式的时候（如从系统调用返回，或者完成一次上下文切换），它会检查进程p的没有被设置为阻塞且又处于待处理状态的信号的集合
  - 用pending & ~blocked来表示
- 如果集合为空，则将控制传递到p的下一条指令；否则，选择，从集合中选择信号k，并强制p接收信号k
  - 这也就解释了，什么时候，一个进程才能真正接收到一个信号，是在进程从内核模式切换到用户模式的时候

- 进程收到信号后，会触发某种行为
  - 每个信号类型都由预定义的默认行为，见图8-26
  - 可以通过signal函数，改变某种信号类型的行为
  - 本章以后的内容见《Unix环境高级编程》